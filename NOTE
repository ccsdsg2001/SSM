1.MyBatis
1.1、MyBatis特性
1） MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架
2） MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集
3） MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain Old Java
Objects，普通的Java对象）映射成数据库中的记录
4） MyBatis 是一个 半自动的ORM（Object Relation Mapping）框架

1.2、和其它持久化层技术对比
JDBC
SQL 夹杂在Java代码中耦合度高，导致硬编码内伤
维护不易且实际开发需求中 SQL 有变化，频繁修改的情况多见
代码冗长，开发效率低
Hibernate 和 JPA
操作简便，开发效率高
程序中的长难复杂 SQL 需要绕过框架
内部自动生产的 SQL，不容易做特殊优化
基于全映射的全自动框架，大量字段的 POJO 进行部分映射时比较困难。
反射操作太多，导致数据库性能下降
MyBatis
轻量级，性能出色
SQL 和 Java 编码分开，功能边界清晰。Java代码专注业务、SQL语句专注数据
开发效率稍逊于HIbernate，但是完全能够接受

2.搭建MyBatis
MySQL不同版本的注意事项 ！mapper接口和映射文件保持一致 1.mapper接口的全类名和映射文件的namespace一致 2.接口中的方法的方法名和映射文件中的sql的id保持一致
1、驱动类driver-class-name
MySQL 5版本使用jdbc5驱动，驱动类使用：com.mysql.jdbc.Driver
MySQL 8版本使用jdbc8驱动，驱动类使用：com.mysql.cj.jdbc.Driver
2、连接地址url
MySQL 5版本的url：
jdbc:mysql://localhost:3306/ssm
MySQL 8版本的url：
jdbc:mysql://localhost:3306/ssm?serverTimezone=UTC
否则运行测试用例报告如下错误：
java.sql.SQLException: The server time zone value 'ÖÐ¹ú±ê×¼Ê±¼ä' is unrecognized or
represents more

2.1创建MyBatis的核心配置文件
习惯上命名为mybatis-config.xml，这个文件名仅仅只是建议，并非强制要求。将来整合Spring
之后，这个配置文件可以省略，所以大家操作时可以直接复制、粘贴。
核心配置文件主要用于配置连接数据库的环境以及MyBatis的全局配置信息
核心配置文件存放的位置是src/main/resources目录下
配置如下：
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
<!--设置连接数据库的环境-->
<environments default="development">
<environment id="development">
<transactionManager type="JDBC"/>
<dataSource type="POOLED">
<property name="driver" value="com.mysql.cj.jdbc.Driver"/>
<property name="url" value="jdbc:mysql://localhost:3306/ssm?
serverTimezone=UTC"/>
<property name="username" value="root"/>
<property name="password" value="123456"/>
</dataSource>
</environment>
</environments>
<!--引入映射文件-->
<mappers>
<package name="mappers/UserMapper.xml"/>
</mappers>
</configuration>

2.2、创建mapper接口
public interface UserMapper {
/**
* 添加用户信息
*/
int insertUser();
}

2.3、创建MyBatis的映射文件
ORM（Object Relationship Mapping）对象关系映射。
对象：Java的实体类对象
关系：关系型数据库
映射：二者之间的对应关系
1、映射文件的命名规则：
表所对应的实体类的类名+Mapper.xml
例如：表t_user，映射的实体类为User，所对应的映射文件为UserMapper.xml
因此一个映射文件对应一个实体类，对应一张表的操作
MyBatis映射文件用于编写SQL，访问以及操作表中的数据
MyBatis映射文件存放的位置是src/main/resources/mappers目录下
2、 MyBatis中可以面向接口操作数据，要保证两个一致：
a>mapper接口的全类名和映射文件的命名空间（namespace）保持一致
b>mapper接口中方法的方法名和映射文件中编写SQL的标签的id属性保持一致
配置如下：
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.atguigu.mybatis.mapper.UserMapper">
<!--int insertUser();-->
<insert id="insertUser">
insert into t_user values(null,'admin','123456',23,'男','12345@qq.com')
</insert>
</mapper>

3.核心配置文件
(1)mybatis-config.xml
配置如下:
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <properties resource="jdbc.properties"></properties>
    <typeAliases>
        <package name=""/>
    </typeAliases>
    <environments default="development">
        <environment id="development">
            <transactionManager type="JDBC"/>
            <dataSource type="POOLED">
                <property name="driver" value="${jdbc.driver}"/>
                <property name="url" value="${jdbc.url}"/>
                <property name="username" value="${jdbc.username}"/>
                <property name="password" value="${jdbc.password}"/>
            </dataSource>
        </environment>
    </environments>
    <mappers>
        <package name=""/>
    </mappers>
</configuration>

(2)UｓｅRMａｐｐｅｒ．ｘｍｌ
如下：
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="">
</mapper>

4.MyBatis获取参数值的两种方式
MyBatis获取参数值的两种方式：${}和#{}
(1)若mapper接口方法的参数为单个的字面量类型
此时可以通过${}和#{}以任意内容获取参数值，一定注意${}的单引号问题

(2)若mapper接口方法的参数为多个的字面量类型
myBatis会将参数放在map集合中,以两种方式存储数据
a>以arg0,arg1...为键,以参数为值
b>以param0,param1...为键,以参数为值
通过#{}和${}访问相应的键,获得对应的值

(3)若mapper接口方法的参数为map集合类型的参数
只需要通过#{}和${}访问map集合的键,就可以获取相对应的值,一定要注意${}的单引号问题

(4)若mapper接口方法的参数为实体类型的参数
只需要通过#{}和${}访问实体类中的属性名,就可以获取相对应的属性值

(5)可以在mapper接口方法上的参数上设置@Param注解
mybatis将这些参数放在map中,以两种方式进行存储
a>以@param注解的value属性值为键,以参数为值
b>以param1,param2...为键,以参数为值
只需要通过#{}和${}访问map集合的键,就可以获取相对应的值,一定要注意${}的单引号问题

5.MyBatis的各种查询功能
(1)查询一个实体类对象
<select id="getUserById" resultType="User">
select * from t_user where id = #{id}
</select>

(2)查询一个list集合
<select id="getUserList" resultType="User">
select * from t_user
</select>
当查询的数据为多条时，不能使用实体类作为返回值，否则会抛出异常
TooManyResultsException；但是若查询的数据只有一条，可以使用实体类或集合作为返回值

(3)查询单个数据
<select id="getCount" resultType="int">
select count(id) from t_user
</select>

(4)查询一条数据为map集合
<select id="getUserToMap" resultType="map">
select * from t_user where id = #{id}
</select>

(5)查询多条数据为map集合
①方式一
将表中的数据以map集合的方式查询，一条数据对应一个map；若有多条数据，就会产生多个map集合，此
时可以将这些map放在一个list集合中获取
List<Map<String, Object>> getAllUserToMap();
<!--Map<String, Object> getAllUserToMap();-->
<select id="getAllUserToMap" resultType="map">
select * from t_user
</select>
②方式二
将表中的数据以map集合的方式查询，一条数据对应一个map；若有多条数据，就会产生多个map集合，并
且最终要以一个map的方式返回数据，此时需要通过@MapKey注解设置map集合的键，值是每条数据所对应的
map集合
*/
@MapKey("id")
Map<String, Object> getAllUserToMap();

6.特殊的SQL执行
（1）模糊查询
<select id="testMohu" resultType="User">
方式一：<!--select * from t_user where username like '%${mohu}%'-->
方式二：<!--select * from t_user where username like concat('%',#{mohu},'%')-->
方式三：select * from t_user where username like "%"#{mohu}"%"
</select>

（2）批量删除
<delete id="deleteMore">
delete from t_user where id in (${ids})
</delete>

(3)动态设置表名
<select id="getAllUser" resultType="User">
select * from ${tableName}
</select>

(4)添加功能获取自增的主键
 useGeneratedKeys：设置使用自增的主键
keyProperty：因为增删改有统一的返回值是受影响的行数，因此只能将获取的自增的主键放在传输的参
数user对象的某个属性中
sample:<insert id="insertUser" useGeneratedKeys="true" keyProperty="id">
       insert into t_user values(null,#{username},#{password},#{age},#{sex})
       </insert>

7.自定义映射resultMap
PS:字段名和实体类中的属性名不一致,则可以通过resultMap设置自定义映射
常用标签:<!--
     resultMap：设置自定义映射
     属性：
     id：表示自定义映射的唯一标识
     type：查询的数据要映射的实体类的类型
     子标签：
     id：设置主键的映射关系
     result：设置普通字段的映射关系
     association：设置多对一的映射关系
     collection：设置一对多的映射关系
     属性：
     property：设置映射关系中实体类中的属性名
     column：设置映射关系中表中的字段名
     -->

(1)resultMap处理字段和属性的映射关系
sample:<resultMap id="userMap" type="User">
       <id property="id" column="id"></id>
       <result property="userName" column="user_name"></result>
       <result property="password" column="password"></result>
       <result property="age" column="age"></result>
       <result property="sex" column="sex"></result>
       </resultMap>
       <!--List<User> testMohu(@Param("mohu") String mohu);-->
       <select id="testMohu" resultMap="userMap">
       <!--select * from t_user where username like '%${mohu}%'-->
       select id,user_name,password,age,sex from t_user where user_name like
       concat('%',#{mohu},'%')
       </select>

       PS:若字段名和实体类中的属性名不一致，但是字段名符合数据库的规则（使用_），实体类中的属性
          名符合Java的规则（使用驼峰）
          此时也可通过以下两种方式处理字段名和实体类中的属性的映射关系
          a>可以通过为字段起别名的方式，保证和实体类中的属性名保持一致
          b>可以在MyBatis的核心配置文件中设置一个全局配置信息mapUnderscoreToCamelCase，可
          以在查询表中数据时，自动将_类型的字段名转换为驼峰
          例如：字段名user_name，设置了mapUnderscoreToCamelCase，此时字段名就会转换为
          userName

(2)多对一映射处理
<1>使用级联方式处理映射关系
sample:<resultMap id="empDeptMap" type="Emp">
       <id column="eid" property="eid"></id>
       <result column="ename" property="ename"></result>
       <result column="age" property="age"></result>
       <result column="sex" property="sex"></result>
       <result column="did" property="dept.did"></result>
       <result column="dname" property="dept.dname"></result>
       </resultMap>
       <!--Emp getEmpAndDeptByEid(@Param("eid") int eid);-->
       <select id="getEmpAndDeptByEid" resultMap="empDeptMap">
       select emp.*,dept.* from t_emp emp left join t_dept dept on emp.did =
       dept.did where emp.eid = #{eid}
       </select>

<2>使用association处理映射关系
sample:<resultMap id="empDeptMap" type="Emp">
       <id column="eid" property="eid"></id>
       <result column="ename" property="ename"></result>
       <result column="age" property="age"></result>
       <result column="sex" property="sex"></result>
       <association property="dept" javaType="Dept">
       <id column="did" property="did"></id>
       <result column="dname" property="dname"></result>
       </association>
       </resultMap>
       <!--Emp getEmpAndDeptByEid(@Param("eid") int eid);-->
       <select id="getEmpAndDeptByEid" resultMap="empDeptMap">
       select emp.*,dept.* from t_emp emp left join t_dept dept on emp.did =
       dept.did where emp.eid = #{eid}
       </select>

<3>分布查询
①查询员工信息
sample:<resultMap id="empDeptStepMap" type="Emp">
       <id column="eid" property="eid"></id>
       <result column="ename" property="ename"></result>
       <result column="age" property="age"></result>
       <result column="sex" property="sex"></result>
       <!--
       select：设置分步查询，查询某个属性的值的sql的标识（namespace.sqlId）
       column：将sql以及查询结果中的某个字段设置为分步查询的条件
       -->
       <association property="dept"
       select="com.atguigu.MyBatis.mapper.DeptMapper.getEmpDeptByStep" column="did">
       </association>
       </resultMap>
       <!--Emp getEmpByStep(@Param("eid") int eid);-->
       <select id="getEmpByStep" resultMap="empDeptStepMap">
       select * from t_emp where eid = #{eid}
       </select>

②根据员工所对应的部门id查询部门信息
sample:<select id="getEmpDeptByStep" resultType="Dept">
       select * from t_dept where did = #{did}
       </select>

(3)一对多映射处理
<1>collection
sample:<resultMap id="deptEmpMap" type="Dept">
       <id property="did" column="did"></id>
       <result property="dname" column="dname"></result>
       <!--
       ofType：设置collection标签所处理的集合属性中存储数据的类型
       -->
       <collection property="emps" ofType="Emp">
       <id property="eid" column="eid"></id>
       <result property="ename" column="ename"></result>
       <result property="age" column="age"></result>
       <result property="sex" column="sex"></result>
       </collection>
       </resultMap>
       <!--Dept getDeptEmpByDid(@Param("did") int did);-->
       <select id="getDeptEmpByDid" resultMap="deptEmpMap">
       select dept.*,emp.* from t_dept dept left join t_emp emp on dept.did =
       emp.did where dept.did = #{did}
       </select>

<2>分布查询
①查询部门信息
sample:<resultMap id="deptEmpStep" type="Dept">
       <id property="did" column="did"></id>
       <result property="dname" column="dname"></result>
       <collection property="emps" fetchType="eager"
       select="com.atguigu.MyBatis.mapper.EmpMapper.getEmpListByDid" column="did">
       </collection>
       </resultMap>
       <!--Dept getDeptByStep(@Param("did") int did);-->
       <select id="getDeptByStep" resultMap="deptEmpStep">
       select * from t_dept where did = #{did}
       </select>

②根据部门id查询部门中的所有员工
sample:<!--List<Emp> getEmpListByDid(@Param("did") int did);-->
       <select id="getEmpListByDid" resultType="Emp">
       select * from t_emp where did = #{did}
       </select>

PS:分布查询的优点:可以实现延迟加载
           但是必须在核心配置文件中设置全局配置信息：
           lazyLoadingEnabled：延迟加载的全局开关。当开启时，所有关联对象都会延迟加载
           aggressiveLazyLoading：当开启时，任何方法的调用都会加载该对象的所有属性。否则，每个属性会按需加载
           此时就可以实现按需加载，获取的数据是什么，就只会执行相应的sql。此时可通过association和
           collection中的fetchType属性设置当前的分步查询是否使用延迟加载， fetchType="lazy(延迟加载)|eager(立即加载)"

8.动态SQL
























p46


















