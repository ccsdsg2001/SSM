1.MyBatis
1.1、MyBatis特性
1） MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架
2） MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集
3） MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain Old Java
Objects，普通的Java对象）映射成数据库中的记录
4） MyBatis 是一个 半自动的ORM（Object Relation Mapping）框架

1.2、和其它持久化层技术对比
JDBC
SQL 夹杂在Java代码中耦合度高，导致硬编码内伤
维护不易且实际开发需求中 SQL 有变化，频繁修改的情况多见
代码冗长，开发效率低
Hibernate 和 JPA
操作简便，开发效率高
程序中的长难复杂 SQL 需要绕过框架
内部自动生产的 SQL，不容易做特殊优化
基于全映射的全自动框架，大量字段的 POJO 进行部分映射时比较困难。
反射操作太多，导致数据库性能下降
MyBatis
轻量级，性能出色
SQL 和 Java 编码分开，功能边界清晰。Java代码专注业务、SQL语句专注数据
开发效率稍逊于HIbernate，但是完全能够接受

2.搭建MyBatis
MySQL不同版本的注意事项 ！mapper接口和映射文件保持一致 1.mapper接口的全类名和映射文件的namespace一致 2.接口中的方法的方法名和映射文件中的sql的id保持一致
1、驱动类driver-class-name
MySQL 5版本使用jdbc5驱动，驱动类使用：com.mysql.jdbc.Driver
MySQL 8版本使用jdbc8驱动，驱动类使用：com.mysql.cj.jdbc.Driver
2、连接地址url
MySQL 5版本的url：
jdbc:mysql://localhost:3306/ssm
MySQL 8版本的url：
jdbc:mysql://localhost:3306/ssm?serverTimezone=UTC
否则运行测试用例报告如下错误：
java.sql.SQLException: The server time zone value 'ÖÐ¹ú±ê×¼Ê±¼ä' is unrecognized or
represents more

2.1创建MyBatis的核心配置文件
习惯上命名为mybatis-config.xml，这个文件名仅仅只是建议，并非强制要求。将来整合Spring
之后，这个配置文件可以省略，所以大家操作时可以直接复制、粘贴。
核心配置文件主要用于配置连接数据库的环境以及MyBatis的全局配置信息
核心配置文件存放的位置是src/main/resources目录下
配置如下：
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
<!--设置连接数据库的环境-->
<environments default="development">
<environment id="development">
<transactionManager type="JDBC"/>
<dataSource type="POOLED">
<property name="driver" value="com.mysql.cj.jdbc.Driver"/>
<property name="url" value="jdbc:mysql://localhost:3306/ssm?
serverTimezone=UTC"/>
<property name="username" value="root"/>
<property name="password" value="123456"/>
</dataSource>
</environment>
</environments>
<!--引入映射文件-->
<mappers>
<package name="mappers/UserMapper.xml"/>
</mappers>
</configuration>

2.2、创建mapper接口
public interface UserMapper {
/**
* 添加用户信息
*/
int insertUser();
}

2.3、创建MyBatis的映射文件
ORM（Object Relationship Mapping）对象关系映射。
对象：Java的实体类对象
关系：关系型数据库
映射：二者之间的对应关系
1、映射文件的命名规则：
表所对应的实体类的类名+Mapper.xml
例如：表t_user，映射的实体类为User，所对应的映射文件为UserMapper.xml
因此一个映射文件对应一个实体类，对应一张表的操作
MyBatis映射文件用于编写SQL，访问以及操作表中的数据
MyBatis映射文件存放的位置是src/main/resources/mappers目录下
2、 MyBatis中可以面向接口操作数据，要保证两个一致：
a>mapper接口的全类名和映射文件的命名空间（namespace）保持一致
b>mapper接口中方法的方法名和映射文件中编写SQL的标签的id属性保持一致
配置如下：
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.atguigu.mybatis.mapper.UserMapper">
<!--int insertUser();-->
<insert id="insertUser">
insert into t_user values(null,'admin','123456',23,'男','12345@qq.com')
</insert>
</mapper>

3.核心配置文件
(1)mybatis-config.xml
配置如下:
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <properties resource="jdbc.properties"></properties>
    <typeAliases>
        <package name=""/>
    </typeAliases>
    <environments default="development">
        <environment id="development">
            <transactionManager type="JDBC"/>
            <dataSource type="POOLED">
                <property name="driver" value="${jdbc.driver}"/>
                <property name="url" value="${jdbc.url}"/>
                <property name="username" value="${jdbc.username}"/>
                <property name="password" value="${jdbc.password}"/>
            </dataSource>
        </environment>
    </environments>
    <mappers>
        <package name=""/>
    </mappers>
</configuration>

(2)UｓｅRMａｐｐｅｒ．ｘｍｌ
如下：
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="">
</mapper>

4.MyBatis获取参数值的两种方式
MyBatis获取参数值的两种方式：${}和#{}
(1)若mapper接口方法的参数为单个的字面量类型
此时可以通过${}和#{}以任意内容获取参数值，一定注意${}的单引号问题

(2)若mapper接口方法的参数为多个的字面量类型
myBatis会将参数放在map集合中,以两种方式存储数据
a>以arg0,arg1...为键,以参数为值
b>以param0,param1...为键,以参数为值
通过#{}和${}访问相应的键,获得对应的值

(3)若mapper接口方法的参数为map集合类型的参数
只需要通过#{}和${}访问map集合的键,就可以获取相对应的值,一定要注意${}的单引号问题

(4)若mapper接口方法的参数为实体类型的参数
只需要通过#{}和${}访问实体类中的属性名,就可以获取相对应的属性值

(5)可以在mapper接口方法上的参数上设置@Param注解
mybatis将这些参数放在map中,以两种方式进行存储
a>以@param注解的value属性值为键,以参数为值
b>以param1,param2...为键,以参数为值
只需要通过#{}和${}访问map集合的键,就可以获取相对应的值,一定要注意${}的单引号问题

5.MyBatis的各种查询功能
(1)查询一个实体类对象
<select id="getUserById" resultType="User">
select * from t_user where id = #{id}
</select>

(2)查询一个list集合
<select id="getUserList" resultType="User">
select * from t_user
</select>
当查询的数据为多条时，不能使用实体类作为返回值，否则会抛出异常
TooManyResultsException；但是若查询的数据只有一条，可以使用实体类或集合作为返回值

(3)查询单个数据
<select id="getCount" resultType="int">
select count(id) from t_user
</select>

(4)查询一条数据为map集合
<select id="getUserToMap" resultType="map">
select * from t_user where id = #{id}
</select>

(5)查询多条数据为map集合
①方式一
将表中的数据以map集合的方式查询，一条数据对应一个map；若有多条数据，就会产生多个map集合，此
时可以将这些map放在一个list集合中获取
List<Map<String, Object>> getAllUserToMap();
<!--Map<String, Object> getAllUserToMap();-->
<select id="getAllUserToMap" resultType="map">
select * from t_user
</select>
②方式二
将表中的数据以map集合的方式查询，一条数据对应一个map；若有多条数据，就会产生多个map集合，并
且最终要以一个map的方式返回数据，此时需要通过@MapKey注解设置map集合的键，值是每条数据所对应的
map集合
*/
@MapKey("id")
Map<String, Object> getAllUserToMap();

6.特殊的SQL执行
（1）模糊查询
<select id="testMohu" resultType="User">
方式一：<!--select * from t_user where username like '%${mohu}%'-->
方式二：<!--select * from t_user where username like concat('%',#{mohu},'%')-->
方式三：select * from t_user where username like "%"#{mohu}"%"
</select>

（2）批量删除
<delete id="deleteMore">
delete from t_user where id in (${ids})
</delete>

(3)动态设置表名
<select id="getAllUser" resultType="User">
select * from ${tableName}
</select>

(4)添加功能获取自增的主键
 useGeneratedKeys：设置使用自增的主键
keyProperty：因为增删改有统一的返回值是受影响的行数，因此只能将获取的自增的主键放在传输的参
数user对象的某个属性中
sample:<insert id="insertUser" useGeneratedKeys="true" keyProperty="id">
       insert into t_user values(null,#{username},#{password},#{age},#{sex})
       </insert>

7.自定义映射resultMap
PS:字段名和实体类中的属性名不一致,则可以通过resultMap设置自定义映射
常用标签:<!--
     resultMap：设置自定义映射
     属性：
     id：表示自定义映射的唯一标识
     type：查询的数据要映射的实体类的类型
     子标签：
     id：设置主键的映射关系
     result：设置普通字段的映射关系
     association：设置多对一的映射关系
     collection：设置一对多的映射关系
     属性：
     property：设置映射关系中实体类中的属性名
     column：设置映射关系中表中的字段名
     -->

(1)resultMap处理字段和属性的映射关系
sample:<resultMap id="userMap" type="User">
       <id property="id" column="id"></id>
       <result property="userName" column="user_name"></result>
       <result property="password" column="password"></result>
       <result property="age" column="age"></result>
       <result property="sex" column="sex"></result>
       </resultMap>
       <!--List<User> testMohu(@Param("mohu") String mohu);-->
       <select id="testMohu" resultMap="userMap">
       <!--select * from t_user where username like '%${mohu}%'-->
       select id,user_name,password,age,sex from t_user where user_name like
       concat('%',#{mohu},'%')
       </select>

       PS:若字段名和实体类中的属性名不一致，但是字段名符合数据库的规则（使用_），实体类中的属性
          名符合Java的规则（使用驼峰）
          此时也可通过以下两种方式处理字段名和实体类中的属性的映射关系
          a>可以通过为字段起别名的方式，保证和实体类中的属性名保持一致
          b>可以在MyBatis的核心配置文件中设置一个全局配置信息mapUnderscoreToCamelCase，可
          以在查询表中数据时，自动将_类型的字段名转换为驼峰
          例如：字段名user_name，设置了mapUnderscoreToCamelCase，此时字段名就会转换为
          userName

(2)多对一映射处理
<1>使用级联方式处理映射关系
sample:<resultMap id="empDeptMap" type="Emp">
       <id column="eid" property="eid"></id>
       <result column="ename" property="ename"></result>
       <result column="age" property="age"></result>
       <result column="sex" property="sex"></result>
       <result column="did" property="dept.did"></result>
       <result column="dname" property="dept.dname"></result>
       </resultMap>
       <!--Emp getEmpAndDeptByEid(@Param("eid") int eid);-->
       <select id="getEmpAndDeptByEid" resultMap="empDeptMap">
       select emp.*,dept.* from t_emp emp left join t_dept dept on emp.did =
       dept.did where emp.eid = #{eid}
       </select>

<2>使用association处理映射关系
sample:<resultMap id="empDeptMap" type="Emp">
       <id column="eid" property="eid"></id>
       <result column="ename" property="ename"></result>
       <result column="age" property="age"></result>
       <result column="sex" property="sex"></result>
       <association property="dept" javaType="Dept">
       <id column="did" property="did"></id>
       <result column="dname" property="dname"></result>
       </association>
       </resultMap>
       <!--Emp getEmpAndDeptByEid(@Param("eid") int eid);-->
       <select id="getEmpAndDeptByEid" resultMap="empDeptMap">
       select emp.*,dept.* from t_emp emp left join t_dept dept on emp.did =
       dept.did where emp.eid = #{eid}
       </select>

<3>分布查询
①查询员工信息
sample:<resultMap id="empDeptStepMap" type="Emp">
       <id column="eid" property="eid"></id>
       <result column="ename" property="ename"></result>
       <result column="age" property="age"></result>
       <result column="sex" property="sex"></result>
       <!--
       select：设置分步查询，查询某个属性的值的sql的标识（namespace.sqlId）
       column：将sql以及查询结果中的某个字段设置为分步查询的条件
       -->
       <association property="dept"
       select="com.atguigu.MyBatis.mapper.DeptMapper.getEmpDeptByStep" column="did">
       </association>
       </resultMap>
       <!--Emp getEmpByStep(@Param("eid") int eid);-->
       <select id="getEmpByStep" resultMap="empDeptStepMap">
       select * from t_emp where eid = #{eid}
       </select>

②根据员工所对应的部门id查询部门信息
sample:<select id="getEmpDeptByStep" resultType="Dept">
       select * from t_dept where did = #{did}
       </select>

(3)一对多映射处理
<1>collection
sample:<resultMap id="deptEmpMap" type="Dept">
       <id property="did" column="did"></id>
       <result property="dname" column="dname"></result>
       <!--
       ofType：设置collection标签所处理的集合属性中存储数据的类型
       -->
       <collection property="emps" ofType="Emp">
       <id property="eid" column="eid"></id>
       <result property="ename" column="ename"></result>
       <result property="age" column="age"></result>
       <result property="sex" column="sex"></result>
       </collection>
       </resultMap>
       <!--Dept getDeptEmpByDid(@Param("did") int did);-->
       <select id="getDeptEmpByDid" resultMap="deptEmpMap">
       select dept.*,emp.* from t_dept dept left join t_emp emp on dept.did =
       emp.did where dept.did = #{did}
       </select>

<2>分布查询
①查询部门信息
sample:<resultMap id="deptEmpStep" type="Dept">
       <id property="did" column="did"></id>
       <result property="dname" column="dname"></result>
       <collection property="emps" fetchType="eager"
       select="com.atguigu.MyBatis.mapper.EmpMapper.getEmpListByDid" column="did">
       </collection>
       </resultMap>
       <!--Dept getDeptByStep(@Param("did") int did);-->
       <select id="getDeptByStep" resultMap="deptEmpStep">
       select * from t_dept where did = #{did}
       </select>

②根据部门id查询部门中的所有员工
sample:<!--List<Emp> getEmpListByDid(@Param("did") int did);-->
       <select id="getEmpListByDid" resultType="Emp">
       select * from t_emp where did = #{did}
       </select>

PS:分布查询的优点:可以实现延迟加载
           但是必须在核心配置文件中设置全局配置信息：
           lazyLoadingEnabled：延迟加载的全局开关。当开启时，所有关联对象都会延迟加载
           aggressiveLazyLoading：当开启时，任何方法的调用都会加载该对象的所有属性。否则，每个属性会按需加载
           此时就可以实现按需加载，获取的数据是什么，就只会执行相应的sql。此时可通过association和
           collection中的fetchType属性设置当前的分步查询是否使用延迟加载， fetchType="lazy(延迟加载)|eager(立即加载)"

8.动态SQL
(1)if
if标签可通过test属性的表达式进行判断，若表达式的结果为true，则标签中的内容会执行；反之
标签中的内容不会执行
sample:<select id="getEmpListByMoreTJ" resultType="Emp">
       select * from t_emp where 1=1
       <if test="ename != '' and ename != null">
       and ename = #{ename}
       </if>
       <if test="age != '' and age != null">
       and age = #{age}
       </if>
       <if test="sex != '' and sex != null">
       and sex = #{sex}
       </if>
       </select>

(2)where
where和if一般结合使用：
a>若where标签中的if条件都不满足，则where标签没有任何功能，即不会添加where关键字
b>若where标签中的if条件满足，则where标签会自动添加where关键字，并将条件最前方多余的
and去掉
注意：where标签不能去掉条件最后多余的and
sample:<select id="getEmpListByMoreTJ2" resultType="Emp">
       select * from t_emp
       <where>
       <if test="ename != '' and ename != null">
       ename = #{ename}
       </if>
       <if test="age != '' and age != null">
       and age = #{age}
       </if>
       <if test="sex != '' and sex != null">
       and sex = #{sex}
       </if>
       </where>
       </select>

(3)trim
trim用于去掉或添加标签中的内容
常用属性：
prefix：在trim标签中的内容的前面添加某些内容
prefixOverrides：在trim标签中的内容的前面去掉某些内容
suffix：在trim标签中的内容的后面添加某些内容
suffixOverrides：在trim标签中的内容的后面去掉某些内容
sample:<select id="getEmpListByMoreTJ" resultType="Emp">
       select * from t_emp
       <trim prefix="where" suffixOverrides="and">
       <if test="ename != '' and ename != null">
            ename = #{ename} and
            </if>
            <if test="age != '' and age != null">
            age = #{age} and
            </if>
            <if test="sex != '' and sex != null">
            sex = #{sex}
            </if>
        </trim>
        </select>

(4)choose,when,otherwise
choose、when、 otherwise相当于if...else if..else
sample:<select id="getEmpListByChoose" resultType="Emp">
       select <include refid="empColumns"></include> from t_emp
       <where>
       <choose>
       <when test="ename != '' and ename != null">
       ename = #{ename}
       </when>
       <when test="age != '' and age != null">
       age = #{age}
       </when>
       <when test="sex != '' and sex != null">
       sex = #{sex}
       </when>
       <when test="email != '' and email != null">
       email = #{email}
       </when>
       </choose>
       </where>
       </select>

(5)foreach
sample:
        <insert id="insertMoreEmp">
        insert into t_emp values
        <foreach collection="emps" item="emp" separator=",">
        (null,#{emp.ename},#{emp.age},#{emp.sex},#{emp.email},null)
        </foreach>
        </insert>
        <!--int deleteMoreByArray(int[] eids);-->
        <delete id="deleteMoreByArray">
        delete from t_emp where
        <foreach collection="eids" item="eid" separator="or">
        eid = #{eid}
        </foreach>
        </delete>
        <!--int deleteMoreByArray(int[] eids);-->
        <delete id="deleteMoreByArray">
        delete from t_emp where eid in
        <foreach collection="eids" item="eid" separator="," open="(" close=")>"
        #{eid}
        </foreach>
        </delete>

(6)SQL片段
sql片段，可以记录一段公共sql片段，在使用的地方通过include标签进行引入
sample：<sql id="empColumns">
       eid,ename,age,sex,did
       </sql>
       select <include refid="empColumns"></include> from t_emp

9.MyBatis的缓存
(1)MyBatis的一级缓存
一级缓存是SqlSession级别的，通过同一个SqlSession查询的数据会被缓存，下次查询相同的数据，就
会从缓存中直接获取，不会从数据库重新访问
使一级缓存失效的四种情况：
1) 不同的SqlSession对应不同的一级缓存
2) 同一个SqlSession但是查询条件不同
3) 同一个SqlSession两次查询期间执行了任何一次增删改操作
4) 同一个SqlSession两次查询期间手动清空了缓存

(2)Mybatis的二级缓存
二级缓存是SqlSessionFactory级别，通过同一个SqlSessionFactory创建的SqlSession查询的结果会被
缓存；此后若再次执行相同的查询语句，结果就会从缓存中获取
二级缓存开启的条件：
a>在核心配置文件中，设置全局配置属性cacheEnabled="true"，默认为true，不需要设置
b>在映射文件中设置标签<cache/>
c>二级缓存必须在SqlSession关闭或提交之后有效
d>查询的数据所转换的实体类类型必须实现序列化的接口
使二级缓存失效的情况：
两次查询之间执行了任意的增删改，会使一级和二级缓存同时失效

(3)二级缓存的相关配置
在mapper配置文件中添加的cache标签可以设置一些属性：
①eviction属性：缓存回收策略，默认的是 LRU。
LRU（Least Recently Used） – 最近最少使用的：移除最长时间不被使用的对象。
FIFO（First in First out） – 先进先出：按对象进入缓存的顺序来移除它们。
SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。
WEAK – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。
②flushInterval属性：刷新间隔，单位毫秒
默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句时刷新
③size属性：引用数目，正整数
代表缓存最多可以存储多少个对象，太大容易导致内存溢出
④readOnly属性：只读， true/false
true：只读缓存；会给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了 很重
要的性能优势。
false：读写缓存；会返回缓存对象的拷贝（通过序列化）。这会慢一些，但是安全，因此默认是
false。

(4)MyBatis缓存查询的顺序
先查询二级缓存，因为二级缓存中可能会有其他程序已经查出来的数据，可以拿来直接使用。
如果二级缓存没有命中，再查询一级缓存
如果一级缓存也没有命中，则查询数据库
SqlSession关闭之后，一级缓存中的数据会写入二级缓存

(5)第三方缓存EHCache
<1>添加依赖
<!-- Mybatis EHCache整合包 -->
<dependency>
<groupId>org.mybatis.caches</groupId>
<artifactId>mybatis-ehcache</artifactId>
<version>1.2.1</version>
</dependency>
<!-- slf4j日志门面的一个具体实现 -->
<dependency>
<groupId>ch.qos.logback</groupId>
<artifactId>logback-classic</artifactId>
<version>1.2.3</version>
</dependency>

<2>jar包功能
jar包名称 作用
mybatis-ehcache Mybatis和EHCache的整合包
ehcache EHCache核心包
slf4j-api SLF4J日志门面包
logback-classic 支持SLF4J门面接口的一个具体实现

<3>创建EHCache的配置文件ehcache.xml
<?xml version="1.0" encoding="utf-8" ?>
<ehcache xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:noNamespaceSchemaLocation="../config/ehcache.xsd">
<!-- 磁盘保存路径 -->
<diskStore path="D:\atguigu\ehcache"/>
<defaultCache
maxElementsInMemory="1000"
maxElementsOnDisk="10000000"
eternal="false"
overflowToDisk="true"
timeToIdleSeconds="120"
timeToLiveSeconds="120"
diskExpiryThreadIntervalSeconds="120"
memoryStoreEvictionPolicy="LRU">
</defaultCache>
</ehcache>

<4>设置二级缓存的类型
<cache type="org.mybatis.caches.ehcache.EhcacheCache"/>

<5>加入logback日志
<?xml version="1.0" encoding="UTF-8"?>
<configuration debug="true">
<!-- 指定日志输出的位置 -->
<appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
<encoder>
<!-- 日志输出的格式 -->
<!-- 按照顺序分别是： 时间、日志级别、线程名称、打印日志的类、日志主体内容、换行
-->
<pattern>[%d{HH:mm:ss.SSS}] [%-5level] [%thread] [%logger]
[%msg]%n</pattern>
</encoder>
</appender>
<!-- 设置全局日志级别。日志级别按顺序分别是： DEBUG、INFO、WARN、ERROR -->
<!-- 指定任何一个日志级别都只打印当前级别和后面级别的日志。 -->
<root level="DEBUG">
<!-- 指定打印日志的appender，这里通过“STDOUT”引用了前面配置的appender -->
<appender-ref ref="STDOUT" />
</root>
<!-- 根据特殊需求指定局部日志级别 -->
<logger name="com.atguigu.crowd.mapper" level="DEBUG"/>
</configuration>

10.MyBatis的逆向工程
正向工程：先创建Java实体类，由框架负责根据实体类生成数据库表。 Hibernate是支持正向工
程的。
逆向工程：先创建数据库表，由框架负责根据数据库表，反向生成如下资源：
Java实体类
Mapper接口
Mapper映射文件
（1）步骤
①添加依赖和插件
sample：<dependencies>
       <dependency>
       <groupId>org.mybatis</groupId>
       <artifactId>mybatis</artifactId>
       <version>3.5.7</version>
       </dependency>
       <!-- junit测试 -->
       <dependency>
       <groupId>junit</groupId>
       <artifactId>junit</artifactId>
       <version>4.12</version>
       <scope>test</scope>
       </dependency>
       <!-- log4j日志 -->
       <dependency>
       <groupId>log4j</groupId>
       <artifactId>log4j</artifactId>
       <version>1.2.17</version>
       </dependency>
       <dependency>
       <groupId>mysql</groupId>
       <artifactId>mysql-connector-java</artifactId>
       <version>8.0.16</version>
       </dependency>
       </dependencies>
       <!-- 控制Maven在构建过程中相关配置 -->
       <build>
       <!-- 构建过程中用到的插件 -->
       <plugins>
       <!-- 具体插件，逆向工程的操作是以构建过程中插件形式出现的 -->
       <plugin>
       <groupId>org.mybatis.generator</groupId>
       <artifactId>mybatis-generator-maven-plugin</artifactId>
       <version>1.3.0</version>
       <!-- 插件的依赖 -->
       <dependencies>
       <!-- 逆向工程的核心依赖 -->
       <dependency>
       <groupId>org.mybatis.generator</groupId>
       <artifactId>mybatis-generator-core</artifactId>
       <version>1.3.2</version>
       </dependency>
       <!-- MySQL驱动 -->
       <dependency>
       <groupId>mysql</groupId>
       <artifactId>mysql-connector-java</artifactId>
       <version>8.0.16</version>
       </dependency>
       </dependencies>
       </plugin>
       </plugins>
       </build>

②创建MyBatis的核心配置文件
③创建逆向工程的配置文件
文件名必须是：generatorConfig.xml
sample:<?xml version="1.0" encoding="UTF-8"?>
       <!DOCTYPE generatorConfiguration
       PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"
       "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd">
       <generatorConfiguration>
       <!--
       targetRuntime: 执行生成的逆向工程的版本
       MyBatis3Simple: 生成基本的CRUD（清新简洁版）
       MyBatis3: 生成带条件的CRUD（奢华尊享版）
       -->
       <context id="DB2Tables" targetRuntime="MyBatis3">
       <!-- 数据库的连接信息 -->
       <jdbcConnection driverClass="com.mysql.cj.jdbc.Driver"
       connectionURL="jdbc:mysql://localhost:3306/mybatis?
       serverTimezone=UTC"
       userId="root"
       password="123456">
       </jdbcConnection>
       <!-- javaBean的生成策略-->
       <javaModelGenerator targetPackage="com.atguigu.mybatis.pojo"
       targetProject=".\src\main\java">
       <property name="enableSubPackages" value="true" />
       <property name="trimStrings" value="true" />
       </javaModelGenerator>
       <!-- SQL映射文件的生成策略 -->
       <sqlMapGenerator targetPackage="com.atguigu.mybatis.mapper"
       targetProject=".\src\main\resources">
       <property name="enableSubPackages" value="true" />
       </sqlMapGenerator>
       <!-- Mapper接口的生成策略 -->
       <javaClientGenerator type="XMLMAPPER"
       targetPackage="com.atguigu.mybatis.mapper" targetProject=".\src\main\java">
       <property name="enableSubPackages" value="true" />
       </javaClientGenerator>
       <!-- 逆向分析的表 -->
       <!-- tableName设置为*号，可以对应所有表，此时不写domainObjectName -->
       <!-- domainObjectName属性指定生成出来的实体类的类名 -->
       <table tableName="t_emp" domainObjectName="Emp"/>
       <table tableName="t_dept" domainObjectName="Dept"/>
       </context>
       </generatorConfiguration>

④执行MBG插件的generate目标

11.分页插件
limit index,pageSize
pageSize：每页显示的条数
pageNum：当前页的页码
index：当前页的起始索引，index=(pageNum-1)*pageSize
count：总记录数
totalPage：总页数
totalPage = count / pageSize;
if(count % pageSize != 0){
totalPage += 1;
}
pageSize=4，pageNum=1，index=0 limit 0,4
pageSize=4，pageNum=3，index=8 limit 8,4
pageSize=4，pageNum=6，index=20 limit 8,4
首页 上一页 2 3 4 5 6 下一页 末页

(1)步骤
①添加依赖
sample:<dependency>
       <groupId>com.github.pagehelper</groupId>
       <artifactId>pagehelper</artifactId>
       <version>5.2.0</version>
       </dependency>


②配置分页插件
在MyBatis的核心配置文件中配置插件
sample:<plugins>
       <!--设置分页插件-->
       <plugin interceptor="com.github.pagehelper.PageInterceptor"></plugin>
       </plugins>

(2)使用
a>在查询功能之前使用PageHelper.startPage(int pageNum, int pageSize)开启分页功能
pageNum：当前页的页码
pageSize：每页显示的条数

b>在查询获取list集合之后，使用PageInfo<T> pageInfo = new PageInfo<>(List<T> list, int
navigatePages)获取分页相关数据
list：分页之后的数据
navigatePages：导航分页的页码数

c>分页相关数据
PageInfo{
pageNum=8, pageSize=4, size=2, startRow=29, endRow=30, total=30, pages=8,
list=Page{count=true, pageNum=8, pageSize=4, startRow=28, endRow=32, total=30,
pages=8, reasonable=false, pageSizeZero=false},
prePage=7, nextPage=0, isFirstPage=false, isLastPage=true, hasPreviousPage=true,
hasNextPage=false, navigatePages=5, navigateFirstPage4, navigateLastPage8,
navigatepageNums=[4, 5, 6, 7, 8]
}
pageNum：当前页的页码
pageSize：每页显示的条数
size：当前页显示的真实条数
total：总记录数
pages：总页数
prePage：上一页的页码
nextPage：下一页的页码
isFirstPage/isLastPage：是否为第一页/最后一页
hasPreviousPage/hasNextPage：是否存在上一页/下一页
navigatePages：导航分页的页码数
navigatepageNums：导航分页的页码，[1,2,3,4,5

-----------------------------------------------------------------------------------------------------------------------------------

Spring框架
1.Spring Framework特性
非侵入式：使用 Spring Framework 开发应用程序时，Spring 对应用程序本身的结构影响非常
小。对领域模型可以做到零污染；对功能性组件也只需要使用几个简单的注解进行标记，完全不会
破坏原有结构，反而能将组件结构进一步简化。这就使得基于 Spring Framework 开发应用程序
时结构清晰、简洁优雅。
控制反转：IOC——Inversion of Control，翻转资源获取方向。把自己创建资源、向环境索取资源
变成环境将资源准备好，我们享受资源注入。
面向切面编程：AOP——Aspect Oriented Programming，在不修改源代码的基础上增强代码功
能。
容器：Spring IOC 是一个容器，因为它包含并且管理组件对象的生命周期。组件享受到了容器化
的管理，替程序员屏蔽了组件创建过程中的大量细节，极大的降低了使用门槛，大幅度提高了开发
效率。
组件化：Spring 实现了使用简单的组件配置组合成一个复杂的应用。在 Spring 中可以使用 XML
和 Java 注解组合这些对象。这使得我们可以基于一个个功能明确、边界清晰的组件有条不紊的搭
建超大型复杂应用系统。
声明式：很多以前需要编写代码才能实现的功能，现在只需要声明需求即可由框架代为实现。
一站式：在 IOC 和 AOP 的基础上可以整合各种企业应用的开源框架和优秀的第三方类库。而且
Spring 旗下的项目已经覆盖了广泛领域，很多方面的功能性需求可以在 Spring Framework 的基
础上全部使用 Spring 来实现。

1.1 Spring Framework五大功能模块
功能模块 功能介绍
Core Container 核心容器，在 Spring 环境下使用任何功能都必须基于 IOC 容器。
AOP&Aspects 面向切面编程
Testing 提供了对 junit 或 TestNG 测试框架的整合。
Data Access/Integration 提供了对数据访问/集成的功能。
Spring MVC 提供了面向Web应用程序的集成功能。

2.IOC
(1)IOC思想
IOC：Inversion of Control，翻译过来是反转控制。
①获取资源的传统方式
在应用程序中的组件需要获取资源时，传统的方式是组件主动的从容器中获取所需要的资源，
在这样的模式下开发人员往往需要知道在具体容器中特定资源的获取方式，增加了学习成本，同时降低了开发效率。

②反转控制方式获取资源
反转控制的思想完全颠覆了应用程序组件获取资源的传统方式：反转了资源的获取方向——改由容器主
动的将资源推送给需要的组件，开发人员不需要知道容器是如何创建资源对象的，只需要提供接收资源
的方式即可，极大的降低了学习成本，提高了开发的效率。这种行为也称为查找的被动形式。

③DI
DI：Dependency Injection，翻译过来是依赖注入。
DI 是 IOC 的另一种表述方式：即组件以一些预先定义好的方式（例如：setter 方法）接受来自于容器
的资源注入。相对于IOC而言，这种表述更直接。
所以结论是：IOC 就是一种反转控制的思想， 而 DI 是对 IOC 的一种具体实现。

(2)IOC容器在Spring中的实现
①BeanFactory
这是 IOC 容器的基本实现，是 Spring 内部使用的接口。面向 Spring 本身，不提供给开发人员使用。

②ApplicationContext
BeanFactory 的子接口，提供了更多高级特性。面向 Spring 的使用者，几乎所有场合都使用
ApplicationContext 而不是底层的 BeanFactory。

③ApplicationContext的主要实现类
类型名 简介
ClassPathXmlApplicationContext 通过读取类路径下的 XML 格式的配置文件创建 IOC 容器
对象
FileSystemXmlApplicationContext 通过文件系统路径读取 XML 格式的配置文件创建 IOC 容
器对象
ConfigurableApplicationContext   ApplicationContext 的子接口，包含一些扩展方法refresh() 和 close() ，让 ApplicationContext 具有启动、关闭和刷新上下文的能力。
WebApplicationContext 专门为 Web 应用准备，基于 Web 环境创建 IOC 容器对
象，并将对象引入存入 ServletContext 域中。

(3)基于XML管理bean
<1>生成pojo类

<2>在Spring的配置文件中配置bean
<!--
配置HelloWorld所对应的bean，即将HelloWorld的对象交给Spring的IOC容器管理
通过bean标签配置IOC容器所管理的bean
属性：
id：设置bean的唯一标识
class：设置bean所对应类型的全类名
-->
<bean id="helloworld" class="com.atguigu.spring.bean.HelloWorld"></bean>

<3>注意
Spring 底层默认通过反射技术调用组件类的无参构造器来创建组件对象，这一点需要注意。如果在需要
无参构造器时，没有无参构造器，则会抛出下面的异常：
org.springframework.beans.factory.BeanCreationException: Error creating bean with name
'helloworld' defined in class path resource [applicationContext.xml]: Instantiation of bean
failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed
to instantiate [com.atguigu.spring.bean.HelloWorld]: No default constructor found; nested
exception is java.lang.NoSuchMethodException: com.atguigu.spring.bean.HelloWorld.<init>

(4)获取bean的三种方式
①方式一：根据id获取
由于 id 属性指定了 bean 的唯一标识，所以根据 bean 标签的 id 属性可以精确获取到一个组件对象。
上个实验中我们使用的就是这种方式。

②方式二：根据类型获取
sample:ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml");
       HelloWorld bean = ac.getBean(HelloWorld.class);
       bean.sayHello();

③方式三：根据id和类型
sample:ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml");
       HelloWorld bean = ac.getBean("helloworld", HelloWorld.class);
       bean.sayHello();

④注意
当根据类型获取bean时，要求IOC容器中指定类型的bean有且只能有一个
当IOC容器中一共配置了两个：
        <bean id="helloworldOne" class="com.atguigu.spring.bean.HelloWorld"></bean>
        <bean id="helloworldTwo" class="com.atguigu.spring.bean.HelloWorld"></bean>

根据类型获取时会抛出异常：
org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean
of type 'com.atguigu.spring.bean.HelloWorld' available: expected single matching bean but
found 2: helloworldOne,helloworldTwo

⑤扩展
如果组件类实现了接口，根据接口类型可以获取 bean 吗？
            可以，前提是bean唯一

如果一个接口有多个实现类，这些实现类都配置了 bean，根据接口类型可以获取 bean 吗？
                不行，因为bean不唯一

⑥结论
根据类型来获取bean时，在满足bean唯一性的前提下，其实只是看：『对象 instanceof 指定的类
型』的返回结果，只要返回的是true就可以认定为和类型匹配，能够获取到。

p70









